import pygame
import time
from typing import List #check 
from enum import Enum 
from button import Button
from abc import ABC, abstractmethod
from Map import Position, RobotPosition, Node, Obstacle,Grid
from simulator import AlgoApp,AlgoSimulator
import json

start_img = pygame.image.load("assets/jasontheween.png").convert_alpha()
exit_img = pygame.image.load("assets/jasontheween.png").convert_alpha()
reset_img = pygame.image.load("assets/jasontheween.png").convert_alpha()

class Direction(Enum):
    LEFT = 180
    TOP = 90
    BOTTOM = -90
    RIGHT = 0
  
RED = (255, 0, 0)
GREEN = (0, 255, 0)
BLUE = (0, 0, 255)

BLACK = (0, 0, 0)
WHITE = (255, 255, 255)

DARK_GREEN = (0, 100, 0)
GREY = (220, 220, 220)
DARK_YELLOW = (236, 183, 83)

PINK = (255, 51, 255)
PURPLE = (153, 51, 255)
DARK_BLUE = (51, 51, 255)
ORANGE = (255, 153, 51)
DARK_GREY = '#6B6B6B'
DARK_BLACK = '#1a1e24'
  
# PyGame settings
SCALING_FACTOR = 5
FRAMES = 60
WINDOW_SIZE = 1300, 1000

# Robot Attributes
ROBOT_LENGTH = 20 * SCALING_FACTOR  # Recommended robot footprint is 30cm by 30cm
ROBOT_TURN_RADIUS = 30 * SCALING_FACTOR
ROBOT_SPEED_PER_SECOND = 30 * SCALING_FACTOR
ROBOT_S_FACTOR = ROBOT_LENGTH / ROBOT_TURN_RADIUS  
ROBOT_SAFETY_DISTANCE = 15 * SCALING_FACTOR
ROBOT_SCAN_TIME = 0.25  # Time provided for scanning an obstacle image in seconds.

# Grid Attributes
GRID_LENGTH = 200 * SCALING_FACTOR  # Movement area is 200cm by 200cm
GRID_CELL_LENGTH = 10 * SCALING_FACTOR  # Grid cell is 10cm by 10cm
GRID_START_BOX_LENGTH = 30 * SCALING_FACTOR  # Recommended starting area is 40cm by 40cm
GRID_NUM_GRIDS = GRID_LENGTH // GRID_CELL_LENGTH  # Number of grid cells

# Obstacle Attributes
OBSTACLE_LENGTH = 10 * SCALING_FACTOR  # Obstacle is 10cm by 10cm
OBSTACLE_SAFETY_WIDTH = ROBOT_SAFETY_DISTANCE // 3 * 4  # With respect to the center of the obstacle

# Path Finding Attributes
PATH_TURN_COST = 999 * ROBOT_SPEED_PER_SECOND * ROBOT_TURN_RADIUS

# NOTE: Higher number == Lower Granularity == Faster Checking.
# Must be an integer more than 0! Number higher than 3 not recommended.
PATH_TURN_CHECK_GRANULARITY = 1


old_obstacles = [{"x":1,"y":18,"direction":-90,"obs_id":0}, 
                 {"x":6,"y":10,"direction":0,"obs_id":1},
                 {"x":15,"y":2,"direction":180,"obs_id":2}, 
                 {"x":15,"y":16,"direction":0,"obs_id":3}]

def parse_obstacle_data_cur(data) -> List[Obstacle]:
    obs = []
    lst3 = []
    lst = []
    i = 0

    for obj in data:
        lst.append(obj)

    for i in lst:
        i["x"] *= 10
        i["x"] += 5
        i["y"] *= 10
        i["y"] += 5
        i["obs_id"] -= 1

    a = [list(row) for row in zip(*[m.values() for m in lst])]

    for i in range(len(a[0])):
        lst2 = [item[i] for item in a]
        lst3.append(lst2)
        i+=1
        
    for obstacle_params in lst3:
        obs.append(Obstacle(obstacle_params[0],
                            obstacle_params[1],
                            Direction(obstacle_params[2]),
                            obstacle_params[3]))

    # [[x, y, orient, index], [x, y, orient, index]]
    return obs 
         


obstacles = parse_obstacle_data_cur(old_obstacles)
app = AlgoSimulator(obstacles)
app.init()
app.execute()

